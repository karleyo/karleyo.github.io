<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2022/12/23/123/"/>
      <url>/2022/12/23/123/</url>
      
        <content type="html"><![CDATA[<h1 id="CSDN-markdown编辑器-使用示例"><a href="#CSDN-markdown编辑器-使用示例" class="headerlink" title="CSDN-markdown编辑器 使用示例"></a>CSDN-markdown编辑器 使用示例</h1><p>本Markdown编辑器使用<a href="https://github.com/benweet/stackedit">StackEdit</a>修改而来，用它写博客，将会带来全新的体验哦：</p><ul><li><strong>Markdown和扩展Markdown简洁的语法</strong></li><li><strong>代码块高亮</strong></li><li><strong>图片链接和图片上传</strong></li><li><strong><em>LaTex</em>数学公式</strong></li><li><strong>UML序列图和流程图</strong></li><li><strong>离线写博客</strong></li><li><strong>导入导出Markdown文件</strong></li><li><strong>丰富的快捷键</strong></li></ul><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>加粗    <code>Ctrl + B</code></li><li>斜体    <code>Ctrl + I</code></li><li>引用    <code>Ctrl + Q</code></li><li>插入链接    <code>Ctrl + L</code></li><li>插入代码    <code>Ctrl + K</code></li><li>插入图片    <code>Ctrl + G</code></li><li>提升标题    <code>Ctrl + H</code></li><li>有序列表    <code>Ctrl + O</code></li><li>无序列表    <code>Ctrl + U</code></li><li>横线    <code>Ctrl + R</code></li><li>撤销    <code>Ctrl + Z</code></li><li>重做    <code>Ctrl + Y</code></li></ul><h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <code>&lt;a href=&quot;https://zh.wikipedia.org/wiki/Markdown&quot; target=&quot;_blank&quot;&gt;</code> [ 维基百科 ]</p></blockquote><p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net/">链接</a>等，详细语法参考帮助？。</p><p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href="https://github.com/jmcmanus/pagedown-extra">Github</a>.</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><p>可以使用冒号来定义对齐方式：</p><table><thead><tr><th align="left">项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td align="left">Computer</td><td align="right">1600 元</td><td align="center">5</td></tr><tr><td align="left">Phone</td><td align="right">12 元</td><td align="center">12</td></tr><tr><td align="left">Pipe</td><td align="right">1 元</td><td align="center">234</td></tr></tbody></table><h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p><strong>Markdown　Extra</strong>　定义列表语法：<br>项目1</p><p>项目2</p><p>:   定义 A</p><p>:   定义 B</p><p>项目3</p><p>:   定义 C</p><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">somefunc</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="自定义字体颜色-github中看不到颜色"><a href="#自定义字体颜色-github中看不到颜色" class="headerlink" title="自定义字体颜色(github中看不到颜色):"></a>自定义字体颜色(github中看不到颜色):</h2><p><code>&lt;font color=0099FF&gt;</code>Hello <code>&lt;/font&gt;</code></p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><del>Hello</del></p><p>###脚注<br>生成一个脚注[^footnote].</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p><p>[toc]</p><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/">math.stackexchange.com</a>.</p><ul><li><p>行内公式，数学公式为：$\Gamma(n) &#x3D; (n-1)!\quad\forall n\in\mathbb N$。</p></li><li><p>块级公式：</p><p>$x &#x3D; \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p></li></ul><p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">这儿</a>.</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure><p>或者流程图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/">这儿</a>,</li><li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li></ul><h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href="http://write.blog.csdn.net/mdeditor">write.blog.csdn.net&#x2F;mdeditor</a> 即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p><p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p><p>博客发表后，本地缓存将被删除。　</p><p>用户可以选择 <code>&lt;i class=&quot;icon-disk&quot;&gt;&lt;/i&gt;</code> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p><blockquote><p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p></blockquote><h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ol><li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li><li>IE9以下不支持</li><li>IE9, 10, 11中存在以下问题<ol><li>不支持离线功能</li><li>IE9不支持文件导入导出</li><li>IE10不支持拖拽文件导入</li></ol></li></ol><hr><h2 id="在csdn-Markdown模式下的显示效果"><a href="#在csdn-Markdown模式下的显示效果" class="headerlink" title="在csdn Markdown模式下的显示效果:"></a>在csdn Markdown模式下的显示效果:</h2><p><a href="https://blog.csdn.net/lzuacm/article/details/81106221">https://blog.csdn.net/lzuacm/article/details/81106221</a></p><p>[^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>]]></content>
      
      
      <categories>
          
          <category> 模板实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2022/12/19/2022-12-19/"/>
      <url>/2022/12/19/2022-12-19/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><p><strong>Neural Machine Translation by Jointly Learning to Align and Translate</strong></p><pre><code>这篇论文由Dzmitry Bahdanau、 KyungHyun Cho 和 Yoshua Bengio 于2015年在深度学习领域的顶级会议ICLP会议上发表。作者提出了一种通过允许模型自动搜索源句子中与预测目标词相关的部分，而不必将这些部分显示分割的解码方法。作者通过这种新的方法达到了与现有的最先进的基于短语的英法翻译系统相当的翻译效果，并通过定性实验发现模型的对齐方式与作者的intuition一致。</code></pre><blockquote><pre><code>This paper was presented in 2015 by Dzmitry Bahdanau, KyungHyun Cho and Yoshua Bengio at the ICLP conference, a top conference in deep learning. The authors propose a decoding method by allowing the model to automatically search for parts of the source sentence that are relevant to the predicted target word, without having to segment these parts of the display. With this new approach the authors achieve translation results comparable to existing state-of-the-art phrase-based English-French translation systems, and find through qualitative experiments that the alignment of the model is consistent with the authors&#39; intuition.</code></pre></blockquote><pre><code>作者在引言部分首先对神经网络机器翻译以及encoder-decoder的工作机制进行了阐述。之后引出了encoder-decoder方法存在的潜在问题，神经网络需要将源句中所有的必要信息压缩成定长的向量，这可能使神经网络难以处理长句子，尤其是那些比训练语料库中更长的句子。作者为了解决这一问题引入了一种对encoder-decoder模型的拓展，每当生成的模型在翻译中生成一个单词的时候，它会搜索源句中最相关信息集中的位置。然后，该模型根据与源句位置相关的上下文向量和之前产生的所有目标词来预测目标词。同时作者阐述了改进的模型与原来的区别以及新模型翻译性能的提升。</code></pre><blockquote><pre><code>The authors begin the introduction with an explanation of neural network machine translation and the mechanism by which encoder-decoder works. A potential problem with the encoder-decoder approach is then introduced, where the neural network needs to compress all the necessary information in the source sentence into a fixed-length vector, which may make it difficult for the neural network to handle long sentences, especially those that are longer than those in the training corpus. The authors introduce an extension to the encoder-decoder model to address this problem, whereby whenever the generated model generates a word in a translation, it searches for the location in the source sentence where the most relevant information is concentrated. The model then predicts the target word based on the context vector associated with the position of the source sentence and all previously generated target words. The authors also describe the differences between the improved model and the original and the improvement in translation performance of the new model.</code></pre></blockquote><pre><code>之后作者对神经机器翻译用到的神经网络框架进行了回顾，并从数学角度对RNN Encoder-Decoder进行了阐述。然后介绍了本文提出的一种新的框架，新的框架由一个双向的RNN作为编码器和一个在解码翻译时对源句模拟搜索的解码器组成。</code></pre><blockquote><pre><code>The authors then review the neural network frameworks used for neural machine translation and describe the RNN Encoder-Decoder from a mathematical perspective. A new framework proposed in this paper is then presented, which consists of a bidirectional RNN as an encoder and a decoder that simulates search on the source sentence when decoding the translation.</code></pre></blockquote><pre><code>作者在实验部分比较了原始的RNN Encoder-Decoder模型和本文提出的改进模型，让这两个模型分别在句子最大长度为 30 和 50 的训练集上训练，并进行了定量分析和定性分析。通过实验作者进一步证明了提出的模型相较于原始的Encoder-Decoder模型在处理长句子方面的优势。</code></pre><blockquote><pre><code>In the experimental section, the authors compare the original RNN Encoder-Decoder model with the improved model proposed in this paper and have the two models trained on training sets with maximum sentence lengths of 30 and 50, respectively, and perform both quantitative and qualitative analyses. Through experiments the authors further demonstrate the advantages of the proposed model over the original Encoder-Decoder model in handling long sentences.</code></pre></blockquote><pre><code>最后作者对本文提出的一种通过允许模型自动搜索源句子中与预测目标词相关的部分，而不必将这些部分显示分割的解码方法进行了总结，并且通过实验结果表明，无论句子长度如何，本文所提出的RNN Search都显著优于传统的Encoder-Decoder模型，且对源句子长度有更强的鲁棒性。并得出了该模型能够在产生正确翻译的同时，正确地将每个目标词与源句中的相关词或它们的注释对齐的结论。与此同时，作者还提出了一个神经机器翻译未来会面临的挑战。</code></pre><blockquote><pre><code>Finally the authors summarise a decoding method proposed in this paper by allowing the model to automatically search for parts of the source sentence that are relevant to the predicted target word without having to segment these parts of the display, and show through experimental results that the RNN Search proposed in this paper significantly outperforms the traditional Encoder-Decoder model regardless of the sentence length and is The proposed RNN Search significantly outperforms the traditional Encoder-Decoder model regardless of the sentence length and is more robust to the source sentence length. It is also concluded that the model is able to correctly align each target word with the relevant words in the source sentence or their annotations while producing the correct translation. At the same time, the authors present a challenge that neural machine translation will face in the future.</code></pre></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/18/hello-world/"/>
      <url>/2022/12/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
